.include "../commons/std_io_minisys.macro.mips"
.data
.text
.globl main
main: # todo: 没什么用，coe文件不能位置无关。
jal static_initialization
begin:
    li $v0 10
    jal sleep # 降低速度
    
    jal decode # 会覆盖a0 a1的值。
    move $a2 $a0
    
    sll $a0 $a0 5
    jal write_control # 指示当前是哪一个case
    set_s_to_be_seven_numbers()
    beq $a2 $zero case0
    beq $a2 $s1 case1
    beq $a2 $s2 case2
    beq $a2 $s3 case3
    beq $a2 $s4 case4
    beq $a2 $s5 case5
    beq $a2 $s6 case6
    beq $a2 $s7 case7
case0:
    jal read
    move $s1 $a0 # s1=n，表示数组长度

    bne $s1 $zero end_if_case0_0
        jal exception_hint  # 如果是0，只是警告，不重新输入。
    end_if_case0_0:
	li $t0 10
    ble $s1  $t0 end_if_case0_1
        jal exception_hint  # 如果比10大，只是警告，不重新输入。
    end_if_case0_1:
    addi $s2 $fp 0 # 0倍的s0， s2现在是数据集0的基地址。
    for_case0:
    	ble $s1 $zero end_for_case0
		# 用control的右边四个灯提示正在读第几个数
		li $v0 0
		srl $v1 $s1 0
		jal write_control_set
		li $v0 1
		srl $v1 $s1 1 
		jal write_control_set
		li $v0 2
		srl $v1 $s1 2
		jal write_control_set
		li $v0 3
		srl $v1 $s1 3 
		jal write_control_set
		sleep(100)
		# 读取新的数。
        jal read
        sw $a0 0($s2) # 存入s2
        addi $s1 $s1 -1
        addi $s2 $s2 4 # 指针右移
        j for_case0
    end_for_case0:
    j begin
case1:
    li $a0 0
    jal write_data
    li $a0 2
    jal write_control
    
    j begin
case2:
    li $v0 7
    jal write_control_set
    j begin
case3:
    li $a0 8
    jal write_control
    j begin
case4:
    li $a0 16
    jal write_control
    j begin
case5:
    li $a0 32
    jal write_control
    j begin
case6:
    li $a0 64
    jal write_control
    j begin
case7:
    li $a0 128
    jal write_control
    j begin
j begin

.include "../commons/std_io_minisys.impl.mips"