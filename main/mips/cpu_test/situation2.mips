.include "../commons/std_io_minisys.macro.mips"
.data
.text
.globl main
main: # todo: 没什么用，coe文件不能位置无关。
jal static_initialization
begin:
    sleep(50)
    
    jal decode # 会覆盖a0 a1的值。
    move $a2 $a0
    
    hint_case_number() # 指示当前是哪一个case. 不会干扰前面已有的灯。
    
    set_s_to_be_seven_numbers()
    beq $a2 $zero case0
    beq $a2 $s1 case1
    beq $a2 $s2 case2
    beq $a2 $s3 case3
    beq $a2 $s4 case4
    beq $a2 $s5 case5
    beq $a2 $s6 case6
    beq $a2 $s7 case7
case0:
    jal read
    move $s1 $a0 # s1=n，表示数组长度
    sw $s1 44($fp) # 44($fp) 为数组长度

    bne $s1 $zero end_if_case0_0
        jal exception_hint  # 如果是0，只是警告，不重新输入。
    end_if_case0_0:
	li $t0 10
    ble $s1  $t0 end_if_case0_1
        jal exception_hint  # 如果比10大，只是警告，不重新输入。
    end_if_case0_1:
    addi $s2 $fp 0 # 0倍的s0， s2现在是数据集0的基地址。
    
    for_case0:
    	ble $s1 $zero end_for_case0
		# 用control的右边四个灯提示正在读第几个数
		li $v0 0
		srl $v1 $s1 0
		jal write_control_set
		li $v0 1
		srl $v1 $s1 1 
		jal write_control_set
		li $v0 2
		srl $v1 $s1 2
		jal write_control_set
		li $v0 3
		srl $v1 $s1 3 
		jal write_control_set
		sleep(100)
		# 读取新的数。
        jal read
        sw $a0 0($s2) # 存入s2对应的内存
        addi $s1 $s1 -1
        addi $s2 $s2 4 # 指针右移
        j for_case0
    end_for_case0:
    warn_data() # 表示输入结束。
    j begin
case1:
    move $v0 $fp # 数据集0头
    lw $s1 44($fp) # 数组实际长度n
    sll $s1 $s1 2 # 数组长度左移两位乘4
    add $v1 $v0 $s1 # 数据集0尾
    add $a0 $v0 $s0 # 数据集1头
    move $s2 $a0 # 数据集1头
    jal copy 
    move $v0 $s2 # 数据集1头
    add $v1 $v0 $s1 # 数据集1尾
    jal insertion_sort
    warn_data() # 表示排序结束。
    j begin
case2:
    move $v0 $fp # 数据集0头
    lw $s1 44($fp) 
    sll $s1 $s1 2 # 数组长度左移两位乘4
    add $v1 $v0 $s1 # 数据集0尾
    add $a0 $v0 $s0 # 数据集1头
    add $a0 $a0 $s0 # 数据集2头
    jal to_signed_array 
    warn_data() 
    j begin
case3:
    move $v0 $fp # 数据集0头
    add $v0 $v0 $s0 # 数据集1头
    add $v0 $v0 $s0 # 数据集2头
    lw $s1 44($fp) 
    sll $s1 $s1 2 # 数组长度左移两位乘4
    add $v1 $v0 $s1 # 数据集2尾
    add $a0 $v0 $s0 # 数据集3头
    move $s2 $a0
    jal copy

    move $v0 $s2 # 数据集3头
    add $v1 $v0 $s1 # 数据集3尾
    jal insertion_sort

    warn_data()  # 表示排序结束。
    j begin
case4:
    getBase()
    # s1 现在是 数据集头
    move $v0 $s1
    lw $s2 44($fp) # n
    sll $s2 $s2 2 # 数组长度左移两位乘4
    add $s2 $v0 $s2 # 数据集尾
    move $v1 $s2
    jal max
    move $s3 $a0 # s3 是最大值
    move $v0 $s1
    move $v1 $s2
    jal min
    move $s4 $a0 # s4 是最小值
    sub $a0 $s3 $s4 
    jal write_data
    j begin
case5:
    getBase()
    # s1 现在是 数据集头
    jal read
    sll $a0 $a0 2 # 下标*4
    add $s1 $s1 $a0 # 目标地址
    lw $a0 0($s1) # 目标数
    jal write_data
    j begin
case6:
    getBase()
    # s1 现在是 数据集头
    jal read
    sll $a0 $a0 2 # 下标*4
    add $s1 $s1 $a0 # 目标地址
    lw $t2 0($s1) # 目标数

    andi $a0 $t2 0xFF # 只考虑8位
    jal getFloat
    jal write_data
    j begin
case7:
    move $s1 $fp # 数据集0 头
    jal read
    sll $a0 $a0 2 # 下标*4
    add $s1 $s1 $a0 # 目标地址
    lw $t2 0($s1) # 目标数

    move $a0 $t2
    jal write_data
    sleep(5000)
    
    move $a0 $t2
    jal getFloat
    jal write_data
    sleep(5000)
    j begin
j begin

.include "../commons/std_io_minisys.impl.mips"
.include "../commons/std_algorithm.mips"
