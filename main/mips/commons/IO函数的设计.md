## IO 函数的设计

### 抢占式IO下软件实现简单的中断

### 整数的长度问题

#### 解决方案1

1. 输入时
- 用户认为看到了Minisys上有16位可以输入。
- 用户认为自己在输入8位/16位整数。
- read函数从MemOrIO实际得到32位的值，which = {0x0000, 开关}
2. 根据用户想法（认为自己输入了8/16位数）
   - 通过合适的转换手段，
   - 保存到a0当中，使得实际上32位的a0
   - 数学上与用户想要输入的数字等价（不一定是相等）。
   - 例如，用户尝试输入8位数 0xFF
     - 用户可以有符号解释它，也可以无符号解释它，
     - 数学上分别对应255和-1
     - 我们处理为32位的0xFFFFFFFF（有符号扩展）。 
       - 则32位有符号解释为-1， 
       - 无符号虽然变大了，
         - 但是前面属于溢出位置，
         - 也就是说，加减法从右往左做运算，在溢出位产生了进位和借位
         - 进位和借位对前面的数有影响，但是不影响后面的数与16/8位数的兼容性。
3. 运算时用32位运算
   - 基于2.中的数学原理，我们可以出结论
   - 对于加法、减法、左移、右移、与、或、非等基础操作
   - 数学上，用32位操作是等价的。
 - 特例：对于逻辑右移，计算结果是错的。
   - 因此，在对数值逻辑右移时，应当先进行逻辑化（取消符号扩展，只取右边8/16位）
3.输出时，
- 先得到了32位的结果，
- 然后只取最后16/8位输出
