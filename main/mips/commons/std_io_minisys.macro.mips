# 让CPU 睡眠msec毫秒。
# 调用这个函数的场景是，switch操作时信号可能不稳定，会出现短时0,1交替，导致计算逻辑有问题。
# note:vivado 仿真时，不启用sleep。因为vivado模拟时没有信号不稳定的问题。
.macro sleep(%msec)
#not vivado
	la $v0 %msec
	jal sleep
#vivado
.end_macro

#测试状态：可信
# 从缓存内存的值写入到灯中。这是private方法，不要轻易调用。
# 会修改t0的值和灯的值。
.macro flush_lights()
	lw $t0 4($k0)
	sw $t0 0x62($gp)
	lw $t0 0($k0)
	sw $t0 0x60($gp)
.end_macro
.macro save_ra()
	addi $sp $sp -4
	sw $ra 0($sp)
	#move $k1 $ra
.end_macro
.macro load_ra()
	lw $ra 0($sp)
	addi $sp $sp 4
	#move $ra $k1 # 动用k1
.end_macro
.macro write_control_set_true(%index)
	li $v0 %index 
	li $v1 1
	jal write_control_set
.end_macro
.macro write_control_set_false(%index)
	li $v0 %index 
	li $v1 0
	jal write_control_set
.end_macro
.macro write_control_negate(%index)
	li $v0 %index 
	jal write_control_negate
.end_macro
.macro set_s_to_be_seven_numbers()
# 常数七子
	li $s1 1
	li $s2 2
	li $s3 3
	li $s4 4
	li $s5 5
	li $s6 6
	li $s7 7
.end_macro

.macro warn_data()
	lw $t7 0($k0)
	li $a0 0xFFFF
	jal write_data
	write_control_set_true(2)
	write_control_set_true(3)
	li $v0 1000
	jal sleep
	move $a0 $t7
	jal write_data
	write_control_set_false(2)
	write_control_set_false(3)
	li $v0 500
	jal sleep
.end_macro 

.macro all_lights_on()
	li $a0 0xFF
	jal write_control
	li $a0 0xFFFF
	jal write_data
.end_macro

.macro all_lights_off()
	li $a0 0
	jal write_control
	li $a0 0
	jal write_data
.end_macro



# 从标准输入读取一个数，表示数据集编号
# 将数据集的基地址放到s1
.macro getBase()
	jal read
	andi $a0 $a0 3 # 只取最后两位。
    lw $s1 0($fp) #base
    for_case4:
        beq $a0 $zero end_for_case4
        add $s1 $s1 $s0 # s0 只读，永远是space
        addi $a0 $a0 -1
        j for_case4
    end_for_case4:
.end_macro

# 从a0 读取case编号，书写到控制灯最左边三位
.macro hint_case_number()
	andi $a0 $a0 0x7 # 只要最后三位
	li $v0 5
	andi $v1 $a0 1 # 最后一位
	jal write_control_set

	srl $a0 $a0 1
	li $v0 6
	andi $v1 $a0 1 # 最后一位
	jal write_control_set

	srl $a0 $a0 1
	li $v0 7
	andi $v1 $a0 1 # 最后一位
	jal write_control_set
	# sleep(200)
.end_macro
