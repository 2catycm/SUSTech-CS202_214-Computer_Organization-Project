#测试状态：可信
# 从缓存内存的值写入到灯中。这是private方法，不要轻易调用。
.macro flush_lights()
	lw $t0 4($k0)
	sw $t0 0x62($gp)
	lw $t0 0($k0)
	sw $t0 0x60($gp)
.end_macro
.macro save_ra()
	addi $sp $sp -4
	sw $ra 0($sp)
.end_macro
.macro load_ra()
	lw $ra 0($sp)
	addi $sp $sp +4
.end_macro
#测试状态：可信
static_initialization:
#MARS模式下这三个指针不要赋值（注释掉）
	la $gp 0xFFFFFC00 # io relative address
	la $sp 256 # 栈指针
	la $fp 512 #base 数据的基础地址
# 数据集间隔
	li $s0 11 #space
# 常数七子
	li $s1 1
	li $s2 2
	li $s3 3
	li $s4 4
	li $s5 5
	li $s6 6
	li $s7 7
	#申请缓存灯的值到一块真实内存。
	addi $sp $sp -16  # 支持0, 4, 8, 12 四个变量
	move $k0 $sp # k0是专门的灯指针
	save_ra() # 要想jal其他方法，先要保存ra
	li $a0 0xFF
	jal write_control
	li $a0 0xFFFF
	jal write_data
	# 1s之后完成操作系统的启动。
	li $v0 1000 
	jal sleep
	li $a0 0
	jal write_control
	li $a0 0
	jal write_data
	load_ra()
	jr $ra
#测试状态：可信
# 睡眠 v0中的毫秒数。公式 T=TPC*CPI*I, 得到I = Tf (T为时间，单位ms, f为时钟频率)
sleep:
	sll $t1 $v0 4  # 23=16+8-1
	sll $t0 $v0 3
	add $t0 $t0 $t1 
	sub $v0 $t0 $v0 
	sll $t1 $v0 10 # 1000=1024-16-8
	sll $t2 $v0 4  
	sll $t0 $v0 3
	sub $v0  $t1 $t2
	sub $v0  $v0 $t0
	_sleep:
	addi $v0 $v0 -1
	bne $v0 $zero _sleep
	jr $ra
#测试状态：可信
# 本asm的控制输入（左开关）定义：左开关前三位为case，第四位为enter。enter为1状态时等待变为0，为0时等待输入的确定。
# decode: 输入a0(左)。解析为a0=case， a1=enter
decode:
	lw $a0 0x72($gp)
	 # 7,6,...,0.  
	 srl $a0 $a0 4
	 andi $a1 $a0 1
	 srl $a0 $a0 1
	 jr $ra
#测试状态：危险
# 根据a1的enter信号控制，等待输入一个整数（通过右开关），结果保存到a0。
# a1和a0都会改变。
read:
	save_ra()
	jal decode
	li $v0 4
	li $v1 1
	jal write_control #提示用户等待enter信号
	bne $a1 $zero read # 如果enter不是0，就继续等待enter是0
	li $v0 4
	li $v1 0
	jal write_control #取消
read_wait_for_enter:
	jal decode
	li $v0 3
	li $v1 1
	jal write_control #提示用户等待enter信号
	beq $a1 $zero read_wait_for_enter # 等到enter是1。 
	li $v0 3
	li $v1 0
	jal write_control #提示用户等待enter信号
	lw $a0 0x70($gp)
	load_ra()
	jr $ra
# 输出控制灯（左灯），根据v0的值(7,6,5,4,3,2,1,0)决定输出修改左边的哪个灯；根据v1的值的最后一位是否是1来修改
write_control_set:
	lw $t1 4($k0) # t1为左灯的值。
	# 操作v1
	andi $v1 $v1 1 # 取最后一位
	sllv $v1 $v1 $v0 # 左移 v0位
	# 让a0的对应位写在t1上。
	srlv $t0 $t1 $v0
	andi $t0 $t0 1 # 取相应位。
	beq $t0 $zero if0
		and $t1 $t1 $v1
		j endif0
	if0:
	    or $t1 $t1 $v1
	endif0:
	sw $t1 4($k0) # 把t1的计算结果送回灯上。
	flush_lights()
	jr $ra
# 输出控制灯（左灯），根据v0的值(7,6,5,4,3,2,1,0)决定输出修改左边的哪个灯；对该灯的值取反。
write_control_negate:
	lw $t1 4($k0) # t1为左灯的值。
	li $t0 1 
	sllv $v1 $t0 $v0 # 左移 v0位
	xor $t1  $t1 $v1
	sw $t1 4($k0) # 把t1的计算结果送回灯上。
	flush_lights()
	jr $ra
#输出控制灯（左灯）; 直接输出a0的值。
write_control:
	sw $a0 4($k0)
	flush_lights()
	jr $ra
#输出数据灯（右灯）; 直接输出a0的值。
write_data:
	sw $a0 0($k0)
	flush_lights()
	jr $ra

